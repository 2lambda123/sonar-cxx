<?xml version="1.0" encoding="us-ascii"?>
<rules>
  <rule key="CustomRuleTemplate">
    <cardinality>MULTIPLE</cardinality>
    <priority>MAJOR</priority>
    <name><![CDATA[Template for custom Custom rules]]></name>
    <description>
      <![CDATA[
<p>
Follow these steps to make your custom Custom rules available in SonarQube:
</p>

<ol>
  <ol>
    <li>Create a new rule in SonarQube by "copying" this rule template and specify the <code>CheckId</code> of your custom rule, a title, a description, and a default severity.</li>
    <li>Enable the newly created rule in your quality profile</li>
  </ol>
  <li>Relaunch an analysis on your projects, et voila, your custom rules are executed!</li>
</ol>
      ]]>
    </description>
  </rule>    
  <rule>
    <key>AssignmentAddressToInteger</key>
    <configkey>AssignmentAddressToInteger</configkey>
    <name>Assigning an address value to an integer (int/long/etc.) type is not portable</name>
    <description>
      <![CDATA[
<p>
Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and
compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux
they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe
way is to store addresses only in pointer types (or typedefs like uintptr_t).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>AssignmentIntegerToAddress</key>
    <configkey>AssignmentIntegerToAddress</configkey>
    <name>Assigning an integer (int/long/etc) to a pointer is not portable</name>
    <description><![CDATA[
<p>
Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and
compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux
they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe
way is to store addresses only in pointer types (or typedefs like uintptr_t).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>autoVariables</key>
    <configkey>autoVariables</configkey>
    <name>Assigning address of local auto-variable to a function parameter</name>
    <description>
<![CDATA[
<p>

    Dangerous assignment - the function parameter is assigned the address of a local
    auto-variable. Local auto-variables are reserved from the stack which
    is freed when the function ends. So the pointer to a local variable is invalid after the function ends
</p>
<p>
    <li>Function parameter is assigned the address of a local auto-variable.</li>
    <li>Local auto-variables are reserved from the stack which is freed when</li>
    <li>the function ends. The address is invalid after the function ends and it</li>
    <li>might 'leak' from the function through the parameter</li>
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>returnAddressOfAutoVariable</key>
    <configkey>returnAddressOfAutoVariable</configkey>
    <name>Return of the address of an auto-variable</name>
    <description>
      <![CDATA[
<p>
Address of an auto-variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>returnLocalVariable</key>
    <configkey>returnLocalVariable</configkey>
    <name>Returning pointer to local array variable</name>
    <description>
<![CDATA[
<p>
Pointer to local array variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>returnReference</key>
    <configkey>returnReference</configkey>
    <name>Returning reference to auto variable</name>
    <description>
<![CDATA[
<p>
Reference to auto variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>returnTempReference</key>
    <configkey>returnTempReference</configkey>
    <name>Returning reference to temporary</name>
    <description>
<![CDATA[
<p>
Reference to temporary returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>autovarInvalidDeallocation</key>
    <configkey>autovarInvalidDeallocation</configkey>
    <name>Deallocating auto-variable is invalid</name>
    <description>
<![CDATA[
<p>
Address of an auto-variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/590.html" target="_blank">CWE-590: Free of Memory not on the Heap</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>arrayIndexOutOfBounds</key>
    <configkey>arrayIndexOutOfBounds</configkey>
    <name>Array index out of bounds</name>
    <description>
<![CDATA[<p>
Array index out of bounds.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=47677453" target="_blank">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/119.html" target="_blank">CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer</a></p>
]]>
</description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>bufferAccessOutOfBounds</key>
    <configkey>bufferAccessOutOfBounds</configkey>
    <name>Buffer access out-of-bounds</name>
    <description>
<![CDATA[
<p>
Buffer is accessed out-of-bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>outOfBounds</key>
    <configkey>outOfBounds</configkey>
    <name>Index is out of bounds: Supplied size is larger than actual size</name>
    <description>
<![CDATA[<p>
Index is out of bounds: Supplied size is larger than actual size.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=47677453" target="_blank">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
    </rule>
  <rule>
    <key>terminateStrncpy</key>
    <configkey>terminateStrncpy</configkey>
    <name>The buffer may not be zero-terminated after the call to strncpy()</name>
    <description>
<![CDATA[
<p>
The buffer 'varname' may not be null-terminated after the call to strncpy().
If the source string's size fits or exceeds the given size, strncpy() does not add a 
zero at the end of the buffer. This causes bugs later in the code if the code 
assumes buffer is null-terminated.
</p>
     ]]>
    </description>
  </rule>
  <rule>
    <key>negativeIndex</key>
    <configkey>negativeIndex</configkey>
    <name>Negative array index</name>
    <description>
<![CDATA[<p>
Negative array index is always out of bounds.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=47677453" target="_blank">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/786.html" target="_blank">CWE-786: Access of Memory Location Before Start of Buffer</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>insecureCmdLineArgs</key>
    <configkey>insecureCmdLineArgs</configkey>
    <name>Buffer overrun possible for long cmd-line args</name>
    <description>
<![CDATA[
<p>
Buffer overrun possible for long command line arguments.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/119.html" target="_blank">CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>pointerOutOfBounds</key>
    <configkey>pointerOutOfBounds</configkey>
    <name>Undefined behaviour, pointer arithmetic 'expr' or index is out of bounds</name>
    <description>
<![CDATA[
<p>
Undefined behaviour, pointer arithmetic 'expr' or index is out of bounds.
From chapter 6.5.6 in the C specification:\n"
<i>"When an expression that has integer type is added to or subtracted from a pointer, .."</i>
 and then 
<i>"If both the pointer operand and the result point to elements of the same array object,
 or one past the last element of the array object,
 the evaluation shall not produce an overflow; otherwise, the behavior is undefined."</i>
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>arrayIndexThenCheck</key>
    <configkey>arrayIndexThenCheck</configkey>
    <name>Array index is used before limits check</name>
    <description>
<![CDATA[<p>
Array index is used before limits check.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=47677453" target="_blank">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
    </rule>
  <rule>
    <key>noConstructor</key>
    <configkey>noConstructor</configkey>
    <name>Class does not have a constructor</name>
    <description>
<![CDATA[
<p>
The <code>struct</code> or <code>class</code> 'classname' does not have a constructor although it has private member variables.
Member variables of builtin types are left uninitialized when the class is instantiated.
That may cause bugs or undefined behavior.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>uninitvar</key>
    <configkey>uninitvar</configkey>
    <name>Uninitialized variable</name>
    <description>
<![CDATA[<p>
Uninitialized variable.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=482" target="_blank">EXP33-C. Do not read uninitialized memory</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/908.html" target="_blank">CWE-908: Use of Uninitialized Resource</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>operatorEqVarError</key>
    <configkey>operatorEqVarError</configkey>
    <name>Member variable is not assigned a value in the assignment operator</name>
    <description>
<![CDATA[
<p>
Member variable is not assigned a value in the assignment '::operator='.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>unusedPrivateFunction</key>
    <configkey>unusedPrivateFunction</configkey>
    <name>Unused private function</name>
    <description>
<![CDATA[
<p>
Unused private function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>memsetClass</key>
    <configkey>memsetClass</configkey>
    <name>Invalid usage of memset|memmove|memcpy on classes</name>
    <description>
<![CDATA[
<p>
Usage of the functions from the memset-family on classes should be avoided because it leads to undefined behavior in a number of
cases (e.g. when the class contains a virtual method). Use constructors or init-routines to initialize your members instead
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a>
</p>
]]>
  </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>operatorEq</key>
    <configkey>operatorEq</configkey>
    <name>'class::operator=' should return 'class &amp;'</name>
    <description>
<![CDATA[
<p>
The 'className::operator=' does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: 
<code>
className &className::operator=(..) 
{ 
  .. 
  return *this; 
}
</code>
For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. 
For more details about this topic, see the book "Effective C++" by Scott Meyers.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>thisSubtraction</key>
    <configkey>thisSubtraction</configkey>
    <name>Suspicious pointer subtraction</name>
    <description>
<![CDATA[
<p>
Suspicious pointer subtraction. Did you intend to write '->'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>operatorEqRetRefThis</key>
    <configkey>operatorEqRetRefThis</configkey>
    <name>'operator=' should return reference to self</name>
    <description>
<![CDATA[
<p>
'operator=' should return reference to self.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>operatorEqToSelf</key>
    <configkey>operatorEqToSelf</configkey>
    <name>'operator=' should check for assignment to self</name>
    <description>
<![CDATA[
<p>
'operator=' should check for assignment to self to ensure that each block of dynamically
allocated memory is owned and managed by only one instance of the class.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>exceptThrowInDestructor</key>
    <configkey>exceptThrowInDestructor</configkey>
    <name>Throwing exception in destructor</name>
    <description>
      Throwing exception in destructor.
    </description>
  </rule>
  <rule>
    <key>exceptDeallocThrow</key>
    <configkey>exceptDeallocThrow</configkey>
    <name>Throwing exception in invalid state</name>
    <description>
      Throwing exception in invalid state: a pointer points at deallocated
      memory.
    </description>
  </rule>
  <rule>
    <key>exceptRethrowCopy</key>
    <configkey>exceptRethrowCopy</configkey>
    <name>Throwing a copy of the caught exception instead of re-throwing the original exception</name>
    <description>
      Throwing a copy of the caught exception instead of re-throwing
      the original exception.
    </description>
  </rule>
  <rule>
    <key>catchExceptionByValue</key>
    <configkey>catchExceptionByValue</configkey>
    <name>Exception should be caught by reference</name>
    <description>
      Exception should be caught by reference.
    </description>
  </rule>
  <rule>
    <key>assignIfError</key>
    <configkey>assignIfError</configkey>
    <name>Mismatching assignment and comparison, comparison is always true or false</name>
    <description>
<![CDATA[
<p>
 Mismatching assignment and comparison, comparison is always true or false.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>comparisonError</key>
    <configkey>comparisonError</configkey>
    <name>Expression is always true or false</name>
    <description>
<![CDATA[
<p>
Expression is always true or false.
Check carefully constants and operators used, these errors might be hard to spot sometimes.
In case of complex expression it might help to split it to separate expressions.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>multiCondition</key>
    <configkey>multiCondition</configkey>
    <name>'else if' condition matches previous condition</name>
    <description>
<![CDATA[
<p>
Expression is always false because 'else if' condition matches previous condition.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>memleak</key>
    <configkey>memleak</configkey>
    <name>Memory leak</name>
    <description>
<![CDATA[
<p>
Memory leak.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank">CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>resourceLeak</key>
    <configkey>resourceLeak</configkey>
    <name>Resource leak</name>
    <description>
<![CDATA[
<p>
Resource leak.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/775.html" target="_blank">CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>deallocDealloc</key>
    <configkey>deallocDealloc</configkey>
    <name>Deallocating a deallocated pointer</name>
    <description>
<![CDATA[
<p>
Deallocating a deallocated pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/415.html" target="_blank">CWE-415: Double Free</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>deallocuse</key>
    <configkey>deallocuse</configkey>
    <name>Dereferencing variable after it is deallocated / released</name>
    <description>
<![CDATA[
<p>
Dereferencing variable after it is deallocated / released.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/416.html" target="_blank">CWE-416: Use After Free</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>mismatchSize</key>
    <configkey>mismatchSize</configkey>
    <name>The given size is mismatching</name>
    <description>
<![CDATA[
<p>
The allocated size is not a multiple of the underlying type&apos;s size.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/131.html" target="_blank">CWE-131: Incorrect Calculation of Buffer Size</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>mismatchAllocDealloc</key>
    <configkey>mismatchAllocDealloc</configkey>
    <name>Mismatching allocation and deallocation</name>
    <description>
<![CDATA[
<p>
Mismatching allocation and deallocation.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>memleakOnRealloc</key>
    <configkey>memleakOnRealloc</configkey>
    <name>Common realloc mistake: variable nulled but not freed upon failure</name>
    <description>
<![CDATA[
<p>
Common realloc mistake: variable nulled but not freed upon failure.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank">CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>nonreentrantFunctionscrypt</key>
    <configkey>nonreentrantFunctionscrypt</configkey>
    <name>Avoid usage of the function 'crypt'</name>
    <description>
      The function 'crypt' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'crypt_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsctermid</key>
    <configkey>nonreentrantFunctionsctermid</configkey>
    <name>Avoid usage of the function 'ctermid'</name>
    <description>
      The function 'ctermid' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'ctermid_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsecvt</key>
    <configkey>nonreentrantFunctionsecvt</configkey>
    <name>Avoid usage of the function 'ecvt'</name>
    <description>
      The function 'ecvt' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'ecvt_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfcvt</key>
    <configkey>nonreentrantFunctionsfcvt</configkey>
    <name>Avoid usage of the function 'fcvt'</name>
    <description>
      The function 'fcvt' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'fcvt_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetgrent</key>
    <configkey>nonreentrantFunctionsfgetgrent</configkey>
    <name>Avoid usage of the function 'fgetgrent'</name>
    <description>
      The function 'fgetgrent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'fgetgrent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetpwent</key>
    <configkey>nonreentrantFunctionsfgetpwent</configkey>
    <name>Avoid usage of the function 'fgetpwent'</name>
    <description>
      The function 'fgetpwent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'fgetpwent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetspent</key>
    <configkey>nonreentrantFunctionsfgetspent</configkey>
    <name>Avoid usage of the function 'fgetspent'</name>
    <description>
      The function 'fgetspent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'fgetspent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgcvt</key>
    <configkey>nonreentrantFunctionsgcvt</configkey>
    <name>Avoid usage of the function 'gcvt'</name>
    <description>
      The function 'gcvt' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'gcvt_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrent</key>
    <configkey>nonreentrantFunctionsgetgrent</configkey>
    <name>Avoid usage of the function 'getgrent'</name>
    <description>
      The function 'getgrent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getgrent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrgid</key>
    <configkey>nonreentrantFunctionsgetgrgid</configkey>
    <name>Avoid usage of the function 'getgrgid'</name>
    <description>
      The function 'getgrgid' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getgrgid_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrnam</key>
    <configkey>nonreentrantFunctionsgetgrnam</configkey>
    <name>Avoid usage of the function 'getgrnam'</name>
    <description>
      The function 'getgrnam' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getgrnam_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyaddr</key>
    <configkey>nonreentrantFunctionsgethostbyaddr</configkey>
    <name>Avoid usage of the function 'gethostbyaddr'</name>
    <description>
      The function 'gethostbyaddr' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'gethostbyaddr_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyname</key>
    <configkey>nonreentrantFunctionsgethostbyname</configkey>
    <name>Avoid usage of the function 'gethostbyname'</name>
    <description>
      The function 'gethostbyname' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'gethostbyname_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyname2</key>
    <configkey>nonreentrantFunctionsgethostbyname2</configkey>
    <name>Avoid usage of the function 'gethostbyname2'</name>
    <description>
      The function 'gethostbyname2' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'gethostbyname2_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostent</key>
    <configkey>nonreentrantFunctionsgethostent</configkey>
    <name>Avoid usage of the function 'gethostent'</name>
    <description>
      The function 'gethostent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'gethostent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetlogin</key>
    <configkey>nonreentrantFunctionsgetlogin</configkey>
    <name>Avoid usage of the function 'getlogin'</name>
    <description>
      The function 'getlogin' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getlogin_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetbyaddr</key>
    <configkey>nonreentrantFunctionsgetnetbyaddr</configkey>
    <name>Avoid usage of the function 'getnetbyaddr'</name>
    <description>
      The function 'getnetbyaddr' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getnetbyaddr_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetbyname</key>
    <configkey>nonreentrantFunctionsgetnetbyname</configkey>
    <name>Avoid usage of the function 'getnetbyname'</name>
    <description>
      The function 'getnetbyname' is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function 'getnetbyname_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetgrent</key>
    <configkey>nonreentrantFunctionsgetnetgrent</configkey>
    <name>Avoid usage of the function 'getnetgrent'</name>
    <description>
      The function 'getnetgrent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getnetgrent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetprotobyname</key>
    <configkey>nonreentrantFunctionsgetprotobyname</configkey>
    <name>Avoid usage of the function 'getprotobyname'</name>
    <description>
      The function 'getprotobyname' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getprotobyname_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwent</key>
    <configkey>nonreentrantFunctionsgetpwent</configkey>
    <name>Avoid usage of the function 'getpwent'</name>
    <description>
      The function 'getpwent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getpwent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwnam</key>
    <configkey>nonreentrantFunctionsgetpwnam</configkey>
    <name>Avoid usage of the function 'getpwnam'</name>
    <description>
      The function 'getpwnam' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getpwnam_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwuid</key>
    <configkey>nonreentrantFunctionsgetpwuid</configkey>
    <name>Avoid usage of the function 'getpwuid'</name>
    <description>
      The function 'getpwuid' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getpwuid_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcbyname</key>
    <configkey>nonreentrantFunctionsgetrpcbyname</configkey>
    <name>Avoid usage of the function 'getrpcbyname'</name>
    <description>
      The function 'getrpcbyname' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getrpcbyname_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcbynumber</key>
    <configkey>nonreentrantFunctionsgetrpcbynumber</configkey>
    <name>Avoid usage of the function 'getrpcbynumber'</name>
    <description>
      The function 'getrpcbynumber' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getrpcbynumber_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcent</key>
    <configkey>nonreentrantFunctionsgetrpcent</configkey>
    <name>Avoid usage of the function 'getrpcent'</name>
    <description>
      The function 'getrpcent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getrpcent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservbyname</key>
    <configkey>nonreentrantFunctionsgetservbyname</configkey>
    <name>Avoid usage of the function 'getservbyname'</name>
    <description>
      The function 'getservbyname' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getservbyname_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservbyport</key>
    <configkey>nonreentrantFunctionsgetservbyport</configkey>
    <name>Avoid usage of the function 'getservbyport'</name>
    <description>
      The function 'getservbyport' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getservbyport_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservent</key>
    <configkey>nonreentrantFunctionsgetservent</configkey>
    <name>Avoid usage of the function 'getservent'</name>
    <description>
      The function 'getservent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getservent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetspent</key>
    <configkey>nonreentrantFunctionsgetspent</configkey>
    <name>Avoid usage of the function 'getspent'</name>
    <description>
      The function 'getspent' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getspent_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetspnam</key>
    <configkey>nonreentrantFunctionsgetspnam</configkey>
    <name>Avoid usage of the function 'getspnam'</name>
    <description>
      The function 'getspnam' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'getspnam_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgmtime</key>
    <configkey>nonreentrantFunctionsgmtime</configkey>
    <name>Avoid usage of the function 'gmtime'</name>
    <description>
      The function 'gmtime' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'gmtime_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionslocaltime</key>
    <configkey>nonreentrantFunctionslocaltime</configkey>
    <name>Avoid usage of the function 'localtime'</name>
    <description>
      The function 'localtime' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'localtime_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsreaddir</key>
    <configkey>nonreentrantFunctionsreaddir</configkey>
    <name>Avoid usage of the function 'readdir'</name>
    <description>
      The function 'readdir' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'readdir_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsstrtok</key>
    <configkey>nonreentrantFunctionsstrtok</configkey>
    <name>Avoid usage of the function 'strtok'</name>
    <description>
      The function 'strtok' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'strtok_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionstempnam</key>
    <configkey>nonreentrantFunctionstempnam</configkey>
    <name>Avoid usage of the function 'tempnam'</name>
    <description>
      The function 'tempnam' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'tempnam_r'.
    </description>
  </rule>
  <rule>
    <key>nonreentrantFunctionsttyname</key>
    <configkey>nonreentrantFunctionsttyname</configkey>
    <name>Avoid usage of the function 'ttyname'</name>
    <description>
      The function 'ttyname' is not reentrant. For thread-safe
      applications it is recommended to use the reentrant replacement
      function 'ttyname_r'.
    </description>
  </rule>
  <rule>
    <key>nullPointer</key>
    <configkey>nullPointer</configkey>
    <name>Possible null pointer dereference</name>
    <description>
<![CDATA[<p>
Possible null pointer dereference.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers" target="_blank">EXP34-C. Do not dereference null pointers</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/476.html" target="_blank">CWE-476: NULL Pointer Dereference</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
    </rule>
  <rule>
    <key>obsoleteFunctionsbcmp</key>
    <configkey>obsoleteFunctionsbcmp</configkey>
    <name>Avoid usage of the function 'bcmp'</name>
    <description>
      The function 'bcmp' is obsolete. It is recommended that new
      applications use the 'memcmp' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsbcopy</key>
    <configkey>obsoleteFunctionsbcopy</configkey>
    <name>Avoid usage of the function 'bcopy'</name>
    <description>
      The function 'bcopy' is obsolete. It is recommended that new
      applications use the 'memmove' or 'memcpy' functions.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsbsd_signal</key>
    <configkey>obsoleteFunctionsbsd_signal</configkey>
    <name>Avoid usage of the function 'bsd_signal'</name>
    <description>
      The function 'bsd_signal' is obsolete. It is recommended that
      new applications use the 'sigaction' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsbzero</key>
    <configkey>obsoleteFunctionsbzero</configkey>
    <name>Avoid usage of the function 'bzero'</name>
    <description>
      The function 'bzero' is obsolete. It is recommended that new
      applications use the 'memset' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsecvt</key>
    <configkey>obsoleteFunctionsecvt</configkey>
    <name>Avoid usage of the function 'ecvt'</name>
    <description>
      The function 'ecvt' is obsolete. It is recommended that new
      applications use the 'sprintf' function
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsfcvt</key>
    <configkey>obsoleteFunctionsfcvt</configkey>
    <name>Avoid usage of the function 'fcvt'</name>
    <description>
      The function 'fcvt' is obsolete. It is recommended that new
      applications use the 'sprintf' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsftime</key>
    <configkey>obsoleteFunctionsftime</configkey>
    <name>Avoid usage of the function 'ftime'</name>
    <description>
      The function 'ftime' is obsolete.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsgcvt</key>
    <configkey>obsoleteFunctionsgcvt</configkey>
    <name>Avoid usage of the function 'gcvt'</name>
    <description>
      The function 'gcvt' is obsolete. It is recommended that new
      applications use the 'sprintf' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsgetcontext</key>
    <configkey>obsoleteFunctionsgetcontext</configkey>
    <name>Avoid usage of the function 'getcontext'</name>
    <description>
      The function 'getcontext' is obsolete. Due to portability issues
      with this function, applications are recommended to be rewritten to
      use POSIX threads.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsgethostbyaddr</key>
    <configkey>obsoleteFunctionsgethostbyaddr</configkey>
    <name>Avoid usage of the function 'gethostbyaddr'</name>
    <description>
      The function 'gethostbyaddr' is obsolete. It is recommended that
      new applications use the 'getnameinfo' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsgethostbyname</key>
    <configkey>obsoleteFunctionsgethostbyname</configkey>
    <name>Avoid usage of the function 'gethostbyname'</name>
    <description>
      The function 'gethostbyname' is obsolete. It is recommended that
      new applications use the 'getaddrinfo' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsgets</key>
    <configkey>obsoleteFunctionsgets</configkey>
    <name>Avoid usage of the function 'gets'</name>
    <description>
      The function 'gets' is obsolete. It is recommended that
      new applications use the 'fgets' function instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsgetwd</key>
    <configkey>obsoleteFunctionsgetwd</configkey>
    <name>Avoid usage of the function 'getwd'</name>
    <description>
      The function 'getwd' is obsolete. It is recommended that new
      applications use the 'getcwd' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsindex</key>
    <configkey>obsoleteFunctionsindex</configkey>
    <name>Avoid usage of the function 'index'</name>
    <description>
      The function 'index' is obsolete. It is recommended to use the
      function 'strchr' instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsmakecontext</key>
    <configkey>obsoleteFunctionsmakecontext</configkey>
    <name>Avoid usage of the function 'makecontext'</name>
    <description>
      The function 'makecontext' is obsolete. Due to portability
      issues with this function, applications are recommended to be
      rewritten to use POSIX threads.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionspthread_attr_getstackaddr</key>
    <configkey>obsoleteFunctionspthread_attr_getstackaddr</configkey>
    <name>Avoid usage of the function 'pthread_attr_getstackaddr'</name>
    <description>
      The function 'pthread_attr_getstackaddr' is obsolete. It is
      recommended that new applications use the 'pthread_attr_getstack'
      function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionspthread_attr_setstackaddr</key>
    <configkey>obsoleteFunctionspthread_attr_setstackaddr</configkey>
    <name>Avoid usage of the function 'pthread_attr_setstackaddr'</name>
    <description>
      The function 'pthread_attr_setstackaddr' is obsolete. It is
      recommended that new applications use the 'pthread_attr_setstack'
      function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsrindex</key>
    <configkey>obsoleteFunctionsrindex</configkey>
    <name>Avoid usage of the function 'rindex'</name>
    <description>
      The function 'rindex' is obsolete. It is recommended to use the
      function 'strrchr' instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsscalbln</key>
    <configkey>obsoleteFunctionsscalbln</configkey>
    <name>Avoid usage of the function 'scalb'</name>
    <description>
      The function 'scalb' is obsolete. It is recommended to use
      either 'scalbln', 'scalblnf' or 'scalblnl' instead of this function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsswapcontext</key>
    <configkey>obsoleteFunctionsswapcontext</configkey>
    <name>Avoid usage of the function 'swapcontext'</name>
    <description>
      The function 'swapcontext' is obsolete. Due to portability
      issues with this function, applications are recommended to be
      rewritten to use POSIX threads.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsualarm</key>
    <configkey>obsoleteFunctionsualarm</configkey>
    <name>Avoid usage of the function 'ualarm'</name>
    <description>
      The function 'ualarm' is obsolete. It is recommended to use
      either 'timer_create', 'timer_delete', 'timer_getoverrun',
      'timer_gettime', or 'timer_settime' instead of this function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsusleep</key>
    <configkey>obsoleteFunctionsusleep</configkey>
    <name>Avoid usage of the function 'usleep'</name>
    <description>
      The function 'usleep' is obsolete. It is recommended that new
      applications use the 'nanosleep' or 'setitimer' function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsvfork</key>
    <configkey>obsoleteFunctionsvfork</configkey>
    <name>Avoid usage of the function 'vfork'</name>
    <description>
      The function 'vfork' is obsolete. It is recommended to use the
      function 'fork' instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionswcswcs</key>
    <configkey>obsoleteFunctionswcswcs</configkey>
    <name>Avoid usage of the function 'wcswcs'</name>
    <description>
      The function 'wcswcs' is obsolete. It is recommended to use the
      function 'wcsstr' instead.
    </description>
  </rule>
  <rule>
    <key>assignBoolToPointer</key>
    <configkey>assignBoolToPointer</configkey>
    <name>Assigning bool value to pointer (converting bool value to address)</name>
    <description>
<![CDATA[
<p>
Boolean value assigned to pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/587.html" target="_blank">CWE-587: Assignment of a Fixed Address to a Pointer</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>sprintfOverlappingData</key>
    <configkey>sprintfOverlappingData</configkey>
    <name>Undefined behavior: variable is used as parameter and destination in s[n]printf()</name>
    <description>
<![CDATA[
<p>
Undefined behavior: variable is used as parameter and destination in s[n]printf(). From Single UNIX Specification: "If
copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined".
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>staticStringCompare</key>
    <configkey>staticStringCompare</configkey>
    <name>Unnecessary comparison of static strings</name>
    <description>
      Unnecessary comparison of static strings.
    </description>
  </rule>
  <rule>
    <key>udivError</key>
    <configkey>udivError</configkey>
    <name>Unsigned division. The result will be wrong</name>
    <description>
      Unsigned division. The result will be wrong.
    </description>
  </rule>
  <rule>
    <key>zerodiv</key>
    <configkey>zerodiv</configkey>
    <name>Division by zero</name>
    <description>
<![CDATA[<p>
Division by zero.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=624" target="_blank">INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/369.html" target="_blank">CWE-369: Divide By Zero</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>wrongmathcall</key>
    <configkey>wrongmathcall</configkey>
    <name>Passing value to () leads to undefined result</name>
    <description>
      Passing value &apos;#&apos; to #() leads to implementation-defined result.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>fflushOnInputStream</key>
    <configkey>fflushOnInputStream</configkey>
    <name>fflush() called on input stream &apos;stdin&apos; may result in undefined behavior</name>
    <description>
      fflush() called on input stream &apos;stdin&apos; may result in undefined behavior on non-linux systems.
    </description>
  </rule>
  <rule>
    <key>functionConst</key>
    <configkey>functionConst</configkey>
    <name>Member function can be const</name>
    <description>
      Technically the member function can be const.
    </description>
  </rule>
  <rule>
    <key>unusedScopedObject</key>
    <configkey>unusedScopedObject</configkey>
    <name>Instance destroyed immediately</name>
    <description>
<![CDATA[
<p>
Instance destroyed immediately.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use ('Unused Variable')</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>sizeofwithsilentarraypointer</key>
    <configkey>sizeofwithsilentarraypointer</configkey>
    <name>Using sizeof on array given as function argument returns the size of pointer</name>
    <description>
      Using &apos;sizeof&apos; for array given as function argument returns the size of pointer.
    </description>
  </rule>
  <rule>
    <key>sizeofwithnumericparameter</key>
    <configkey>sizeofwithnumericparameter</configkey>
    <name>Using sizeof with a numeric constant as function argument might not be what you intended</name>
    <description>
      Using sizeof with a numeric constant as function argument might
      not be what you intended.
    </description>
  </rule>
  <rule>
    <key>cstyleCast</key>
    <configkey>cstyleCast</configkey>
    <name>C-style pointer casting</name>
    <description>
      C-style pointer casting.
    </description>
  </rule>
  <rule>
    <key>dangerousUsageStrtol</key>
    <configkey>dangerousUsageStrtol</configkey>
    <name>Invalid radix in call to strtol or strtoul. Must be 0 or 2-36</name>
    <description>
      Invalid radix in call to strtol or strtoul. Must be 0 or 2-36.
    </description>
  </rule>
  <rule>
    <key>passedByValue</key>
    <configkey>passedByValue</configkey>
    <name>Function parameter should be passed by reference</name>
    <description>
      Function parameter should be passed by reference.
    </description>
  </rule>
  <rule>
    <key>constStatement</key>
    <configkey>constStatement</configkey>
    <name>Redundant code: Found a statement that begins with type constant</name>
    <description>
      Redundant code: Found a statement that begins with type constant.
    </description>
  </rule>
  <rule>
    <key>charArrayIndex</key>
    <configkey>charArrayIndex</configkey>
    <name>Using char type as array index</name>
    <description>
      Using char type as array index.
    </description>
  </rule>
  <rule>
    <key>charBitOp</key>
    <configkey>charBitOp</configkey>
    <name>When using char variables in bit operations, sign extension can generate unexpected results</name>
    <description>
      When using char variables in bit operations, sign extension can
      generate unexpected results.
    </description>
  </rule>
  <rule>
    <key>variableScope</key>
    <configkey>variableScope</configkey>
    <name>The scope of the variable can be reduced</name>
    <description>
      The scope of the variable can be reduced.
    </description>
  </rule>
  <rule>
    <key>strPlusChar</key>
    <configkey>strPlusChar</configkey>
    <name>Unusual pointer arithmetic</name>
    <description>
<![CDATA[
<p>
Unusual pointer arithmetic.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>sizeofsizeof</key>
    <configkey>sizeofsizeof</configkey>
    <name>Calling sizeof for 'sizeof'</name>
    <description>
      Calling sizeof for 'sizeof'.
    </description>
  </rule>
  <rule>
    <key>sizeofCalculation</key>
    <configkey>sizeofCalculation</configkey>
    <name>Found calculation inside sizeof()</name>
    <description>
      Found calculation inside sizeof().
    </description>
  </rule>
  <rule>
    <key>redundantAssignInSwitch</key>
    <configkey>redundantAssignInSwitch</configkey>
    <name>Redundant assignment in switch</name>
    <description>
      Redundant assignment in switch.
    </description>
  </rule>
  <rule>
    <key>switchCaseFallThrough</key>
    <configkey>switchCaseFallThrough</configkey>
    <name>Switch falls through case without comment</name>
    <description>
      Switch falls through case without comment.
    </description>
  </rule>
  <rule>
    <key>selfAssignment</key>
    <configkey>selfAssignment</configkey>
    <name>Redundant assignment to itself</name>
    <description>
      Redundant assignment to itself.
    </description>
  </rule>
  <rule>
    <key>assignmentInAssert</key>
    <configkey>assignmentInAssert</configkey>
    <name>Assert statement modifies variable</name>
    <description>
      <![CDATA[
<p>
Variable 'varname' is modified insert assert statement.
Assert statements are removed from release builds so the code inside
assert statement is not executed. If the code is needed also in release
builds, this is a bug.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>invalidscanf</key>
    <configkey>invalidscanf</configkey>
    <name>scanf without field width limits can crash with huge input data</name>
    <description>
      scanf without field width limits can crash with huge input data.
    </description>
  </rule>
  <rule>
    <key>incorrectLogicOperator</key>
    <configkey>incorrectLogicOperator</configkey>
    <name>Suspicious use of the '&amp;&amp;' or '||' logic operator</name>
    <description>
<![CDATA[
<p>
Logical disjunction always evaluates to true or false . Did you intend to use '&&' or '||' instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a>
</p>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>memsetZeroBytes</key>
    <configkey>memsetZeroBytes</configkey>
    <name>Effectless memset() call</name>
    <description>
      memset() called to fill 0 bytes.
    </description>
  </rule>
  <rule>
    <key>clarifyCalculation</key>
    <configkey>clarifyCalculation</configkey>
    <name>Clarify calculation precedence for + and ?</name>
    <description>
      Clarify calculation precedence for + and ?
    </description>
  </rule>
  <rule>
    <key>clarifyCondition</key>
    <configkey>clarifyCondition</configkey>
    <name>Suspicious condition (assignment+comparison)</name>
    <description>
<![CDATA[
<p>
<ul>
<li>Suspicious condition (assignment+comparison), it can be clarified with parentheses.</li
<li>Suspicious expression. Boolean result is used in bitwise operation. The operator '!'
and the comparison operators have higher precedence than bitwise operators.
It is recommended that the expression is clarified with parentheses.</li
<li>Suspicious condition (bitwise operator + comparison).
Comparison operators have higher precedence than bitwise operators.
Please clarify the condition with parentheses.</li
</ul>
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>incorrectStringCompare</key>
    <configkey>incorrectStringCompare</configkey>
    <name>Mismatch of the string literal and legth argument for substr()</name>
    <description>
      String literal doesn't match length argument for substr().
    </description>
  </rule>
  <rule>
    <key>incrementboolean</key>
    <configkey>incrementboolean</configkey>
    <name>Suspicious use of the postfix '++' operator on a boolean</name>
    <description>
<![CDATA[
<p>
The operand of a postfix increment operator may be of type bool but it is deprecated by C++ Standard (Annex D-1) 
and the operand is always set to true. You should assign it the value 'true' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>comparisonOfBoolWithInt</key>
    <configkey>comparisonOfBoolWithInt</configkey>
    <name>Suspicious comparison of a boolean with an integer</name>
    <description>
      Comparison of a boolean with an integer that is neither 1 nor 0.
    </description>
  </rule>
  <rule>
    <key>duplicateIf</key>
    <configkey>duplicateIf</configkey>
    <name>Redundant 'if'-expressions</name>
    <description>
      Found duplicate if expressions.
    </description>
  </rule>
  <rule>
    <key>duplicateBranch</key>
    <configkey>duplicateBranch</configkey>
    <name>Redundant 'if' and 'else' branches</name>
    <description>
      Found duplicate branches for if and else.
    </description>
  </rule>
  <rule>
    <key>duplicateExpression</key>
    <configkey>duplicateExpression</configkey>
    <name>Same expression on both sides of '&amp;&amp;'</name>
    <description>
      Same expression on both sides of '&amp;&amp;'.
    </description>
  </rule>
  <rule>
    <key>duplicateBreak</key>
    <configkey>duplicateBreak</configkey>
    <name>Consecutive return, break, continue, goto or throw statements are unnecessary</name>
    <description>
      Consecutive return, break, continue, goto or throw statements
      are unnecessary.
    </description>
  </rule>
  <rule>
    <key>unsignedLessThanZero</key>
    <configkey>unsignedLessThanZero</configkey>
    <name>Checking if unsigned variable is less than zero</name>
    <description>
      Checking if unsigned variable is less than zero.
    </description>
  </rule>
  <rule>
    <key>unsignedPositive</key>
    <configkey>unsignedPositive</configkey>
    <name>An unsigned variable can't be negative so it is unnecessary to test it</name>
    <description>
      An unsigned variable can't be negative so it is unnecessary to
      test it.
    </description>
  </rule>
  <rule>
    <key>invalidIterator1</key>
    <configkey>invalidIterator1</configkey>
    <name>Invalid iterator</name>
    <description>
<![CDATA[
<p>
Invalid iterator.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>iterators</key>
    <configkey>iterators</configkey>
    <name>Same iterator is used with two different containers</name>
    <description>
<![CDATA[
<p>
Same iterator is used with two different containers.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>mismatchingContainers</key>
    <configkey>mismatchingContainers</configkey>
    <name>Mismatching containers</name>
    <description>
<![CDATA[
<p>
Iterators of different containers are used together
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>eraseDereference</key>
    <configkey>eraseDereference</configkey>
    <name>Dereferenced iterator an already erased iterator</name>
    <description>
<![CDATA[
<p>
Dereferenced iterator an already erased iterator.
Dereferencing or comparing it with another iterator is invalid operation.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>stlOutOfBounds</key>
    <configkey>stlOutOfBounds</configkey>
    <name>When i==foo.size(), foo[i] is out of bounds</name>
    <description>
<![CDATA[
<p>
When <code>i==foo.size()</code> foo[i] or foo.at(i) is out of bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>invalidIterator2</key>
    <configkey>invalidIterator2</configkey>
    <name>Iterators may get invalid after push_back|push_front|insert</name>
    <description>
<![CDATA[
<p>
Iterators may get invalid after push_back|push_front|insert.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>invalidPointer</key>
    <configkey>invalidPointer</configkey>
    <name>Invalid pointer after push_back / push_front</name>
    <description>
<![CDATA[
<p>
Invalid pointer after push_back / push_front.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>stlBoundries</key>
    <configkey>stlBoundries</configkey>
    <name>Dangerous container iterator compare using &lt; operator for container</name>
    <description>
      Dangerous container iterator compare using &lt; operator for
      container.
    </description>
  </rule>
  <rule>
    <key>stlIfFind</key>
    <configkey>stlIfFind</configkey>
    <name>Suspicious condition. The result of find is an iterator, but it is not properly checked</name>
    <description>
      Suspicious condition. The result of find is an iterator, but it
      is not properly checked.
    </description>
  </rule>
  <rule>
    <key>stlIfStrFind</key>
    <configkey>stlIfStrFind</configkey>
    <name>Suspicious checking of string::find() return value</name>
    <description>
      Inefficient usage of string::find in condition. string::find
      will return '0' if the string is found at position '0'. If this is
      what you want to check then string::compare is a faster alternative
      because it doesn't scan through the string.
    </description>
  </rule>
  <rule>
    <key>stlcstr</key>
    <configkey>stlcstr</configkey>
    <name>Dangerous usage of c_str(). The returned value by c_str() is invalid after this call</name>
    <description>
<![CDATA[
<p>
Dangerous usage of c_str(). The returned value by c_str() is invalid after this call.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>stlSize</key>
    <configkey>stlSize</configkey>
    <name>Prefer .empty() to .size() == 0 for emptiness checking</name>
    <description>
      Possible inefficient checking for emptiness. Using .empty()
      instead of .size() can be faster.
    </description>
  </rule>
  <rule>
    <key>redundantIfRemove</key>
    <configkey>redundantIfRemove</configkey>
    <name>Redundant checking of STL container element</name>
    <description>
      Redundant checking of STL container element.
    </description>
  </rule>
  <rule>
    <key>useAutoPointerCopy</key>
    <configkey>useAutoPointerCopy</configkey>
    <name>Be careful when using 'auto_ptr' copy</name>
    <description>
      Copy 'auto_ptr' pointer to another do not create two equal
      objects since one has lost its ownership of the pointer.
    </description>
  </rule>
  <rule>
    <key>useAutoPointerContainer</key>
    <configkey>useAutoPointerContainer</configkey>
    <name>Don't store 'auto-ptr' in a STL container</name>
    <description>
<![CDATA[
<p>
You can randomly lose access to pointers if you store 'auto_ptr' pointers in a container because the copy-semantics of 'auto_ptr' are not compatible with containers.
An element of container must be able to be copied but 'auto_ptr' does not fulfill this requirement. You should consider to use 'shared_ptr' or 'unique_ptr'.
It is suitable for use in containers, because they no longer copy their values, they move them.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>useAutoPointerArray</key>
    <configkey>useAutoPointerArray</configkey>
    <name>Usage of 'auto_ptr' for pointers obtained with operator 'new[]'</name>
    <description>
<![CDATA[
<p>
Object pointed by an 'auto_ptr' is destroyed using operator 'delete'. This means that you should only use 'auto_ptr' for pointers obtained with operator 'new'.
This excludes arrays, which are allocated by operator 'new[]' and must be deallocated by operator 'delete[]'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>uninitstring</key>
    <configkey>uninitstring</configkey>
    <name>Dangerous usage of variable (strncpy doesn't always 0-terminate it)</name>
    <description>
<![CDATA[<p>
Dangerous usage of variable (strncpy doesn't always 0-terminate it).
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=482" target="_blank">EXP33-C. Do not read uninitialized memory</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/676.html" target="_blank">CWE-676: Use of Potentially Dangerous Function</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>uninitdata</key>
    <configkey>uninitdata</configkey>
    <name>Data is allocated but not initialized</name>
    <description>
<![CDATA[<p>
Data is allocated but not initialized.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=482" target="_blank">EXP33-C. Do not read uninitialized memory</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/908.html" target="_blank">CWE-908: Use of Uninitialized Resource</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>unusedFunction</key>
    <configkey>unusedFunction</configkey>
    <name>Unused function</name>
    <description>
      The function is never used.
    </description>
  </rule>
  <rule>
    <key>unusedVariable</key>
    <configkey>unusedVariable</configkey>
    <name>Unused variable</name>
    <description>
      Unused variable.
    </description>
  </rule>
  <rule>
    <key>unusedAllocatedMemory</key>
    <configkey>unusedAllocatedMemory</configkey>
    <name>Variable is allocated memory that is never used</name>
    <description>
      Variable is allocated memory that is never used.
    </description>
  </rule>
  <rule>
    <key>unreadVariable</key>
    <configkey>unreadVariable</configkey>
    <name>Unused value</name>
    <description>
      Variable is assigned a value that is never used.
    </description>
  </rule>
  <rule>
    <key>unassignedVariable</key>
    <configkey>unassignedVariable</configkey>
    <name>Variable is not assigned a value</name>
    <description>
      Variable is not assigned a value.
    </description>
  </rule>
  <rule>
    <key>unusedStructMember</key>
    <configkey>unusedStructMember</configkey>
    <name>Unused struct or union member</name>
    <description>
      Struct or union member is never used.
    </description>
  </rule>
  <rule>
    <key>postfixOperator</key>
    <configkey>postfixOperator</configkey>
    <name>Prefer prefix ++/-- operators for non-primitive types</name>
    <description>
      Pre-increment/decrement can be more efficient than
      post-increment/decrement. Post-increment/decrement usually involves
      keeping a copy of the previous value around and adds a little extra
      code.
    </description>
  </rule>
  <rule>
    <key>syntaxError</key>
    <configkey>syntaxError</configkey>
    <name>Syntax error</name>
    <description>
      Cppcheck cannot tokenize the code correctly.
    </description>
  </rule>
  <rule>
    <key>cppcheckError</key>
    <configkey>cppcheckError</configkey>
    <name>Internal cppcheck error</name>
    <description>
      Analysis failed. If the code is valid then please report this
      failure.
    </description>
  </rule>
  <rule>
    <key>unnecessaryForwardDeclaration</key>
    <configkey>unnecessaryForwardDeclaration</configkey>
    <name>Redundant forward declaration</name>
    <description>
      Forward declaration unnecessary, already declared.
    </description>
  </rule>
  <rule>
    <key>variableHidingEnum</key>
    <configkey>variableHidingEnum</configkey>
    <name>Variable hides enumerator with same name</name>
    <description>
      Variable hides enumerator with same name.
    </description>
  </rule>
  <rule>
    <key>variableHidingTypedef</key>
    <configkey>variableHidingTypedef</configkey>
    <name>Variable hides typedef with same name</name>
    <description>
      Variable hides typedef with same name
    </description>
  </rule>
  <rule>
    <key>unnecessaryQualification</key>
    <configkey>unnecessaryQualification</configkey>
    <name>Unnecessary qualification</name>
    <description>
      Extra qualification is unnecessary and considered an error by
      many compilers.
    </description>
  </rule>
  <rule>
    <key>missingInclude</key>
    <configkey>missingInclude</configkey>
    <name>Missing include</name>
    <description>
      An include file cannot be found.
    </description>
    <tag>tool-error</tag>
  </rule>
  <rule>
    <key>preprocessorErrorDirective</key>
    <configkey>preprocessorErrorDirective</configkey>
    <name>Preprocessor directive error</name>
    <description>
      Preprocessor directive error.
    </description>
  </rule>
  <rule>
    <key>publicAllocationError</key>
    <configkey>publicAllocationError</configkey>
    <name>Possible leak in public function</name>
    <description>
      Possible leak in public function. The pointer is not deallocated before it is allocated.
    </description>
  </rule>
  <rule>
    <key>sizeArgumentAsChar</key>
    <configkey>sizeArgumentAsChar</configkey>
    <name>The size argument is given as a char constant</name>
    <description>
      The size argument is given as a char constant.
    </description>
  </rule>
  <!-- ########### New in cppcheck 1.51 ########### -->
  <rule>
    <key>bufferNotZeroTerminated</key>
    <configkey>bufferNotZeroTerminated</configkey>
    <name>Buffer is not zero-terminated</name>
    <description>
      A buffer is not zero-terminated after a call to a function.
    </description>
  </rule>
  <rule>
    <key>initializerList</key>
    <configkey>initializerList</configkey>
    <name>Member variable is in wrong order in the initializer list</name>
    <description>
      Member variable is in wrong order in the initializer list.
    </description>
  </rule>
  <rule>
    <key>possibleBufferAccessOutOfBounds</key>
    <configkey>possibleBufferAccessOutOfBounds</configkey>
    <name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination)</name>
    <description>
<![CDATA[<p>
Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination).
The source buffer is larger than or equal the destination buffer so there is the potential for overflowing the destination buffer.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=47677453" target="_blank">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>returnAddressOfFunctionParameter</key>
    <configkey>returnAddressOfFunctionParameter</configkey>
    <name>Return the address of a function parameter</name>
    <description>
<![CDATA[
<p>
Address of the function parameter 'varname' becomes invalid after the function exits because
function parameters are stored on the stack which is freed when the function exits. Thus the returned value is invalid.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>

  <!-- ########### New in cppcheck 1.52 ########### -->
  <rule>
    <key>simplePatternError</key>
    <configkey>simplePatternError</configkey>
    <name>Found simple pattern inside call</name>
    <description>
      Found simple pattern inside call.
    </description>
  </rule>
  <rule>
    <key>complexPatternError</key>
    <configkey>complexPatternError</configkey>
    <name>Found complex pattern inside call</name>
    <description>
      Found complex pattern inside call.
    </description>
  </rule>
  <rule>
    <key>missingPercentCharacter</key>
    <configkey>missingPercentCharacter</configkey>
    <name>Missing percent end character in pattern</name>
    <description>
      Missing percent end character in pattern.
    </description>
  </rule>
  <rule>
    <key>boostForeachError</key>
    <configkey>boostForeachError</configkey>
    <name>Invalid usage of BOOST_FOREACH</name>
    <description>
<![CDATA[
<p>
BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>compareBoolExpressionWithInt</key>
    <configkey>compareBoolExpressionWithInt</configkey>
    <name>Comparison of a boolean expression with an integer other than 0 or 1</name>
    <description>
<![CDATA[
<p>
Comparison of a boolean expression with an integer other than 0 or 1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>coutCerrMisusage</key>
    <configkey>coutCerrMisusage</configkey>
    <name>Invalid usage of output stream: '&lt;&lt; std::cout'</name>
    <description>
      Invalid usage of output stream: '&lt;&lt; std::cout'.
    </description>
  </rule>
  <rule>
    <key>incorrectStringBooleanError</key>
    <configkey>incorrectStringBooleanError</configkey>
    <name>Suspicious comparison of boolean with a string literal</name>
    <description>
      A boolean comparison with the string literal is always true.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>stringCompare</key>
    <configkey>stringCompare</configkey>
    <name>Comparison of identical string variables</name>
    <description>
      Comparison of identical string variables.
    </description>
  </rule>
  <rule>
    <key>stlcstrthrow</key>
    <configkey>stlcstrthrow</configkey>
    <name>The returned value by c_str() is invalid after throw call</name>
    <description>
      The returned value by c_str() is invalid after throw call.
    </description>
  </rule>
  <rule>
    <key>unreachableCode</key>
    <configkey>unreachableCode</configkey>
    <name>Statements following return, break, continue, goto or throw will never be executed</name>
    <description>
      Statements following return, break, continue, goto or throw will
      never be executed.
    </description>
  </rule>
  <rule>
    <key>uselessCallsCompare</key>
    <configkey>uselessCallsCompare</configkey>
    <name>It is inefficient to call 'str.find(str)' as it always returns 0</name>
    <description>
      It is inefficient to call 'str.find(str)' as it always returns 0.
    </description>
  </rule>
  <rule>
    <key>uselessCallsSwap</key>
    <configkey>uselessCallsSwap</configkey>
    <name>It is inefficient to swap a object with itself by calling 'str.swap(str)'</name>
    <description>
      It is inefficient to swap a object with itself by calling
      'str.swap(str)'.
    </description>
  </rule>
  <rule>
    <key>uselessCallsSubstr</key>
    <configkey>uselessCallsSubstr</configkey>
    <name>Function 'substr' useless call. Function create copy of the 'str' object</name>
    <description>
      Useless call of function 'substr' because it returns a copy of the object. Use operator= instead.
    </description>
  </rule>
  <rule>
    <key>wrongcctypecall</key>
    <configkey>wrongcctypecall</configkey>
    <name>Wrong usage of a function from the ctype-family</name>
    <description>
      Passing negative values to the functions of the ctype-family
      (isalnum|isalpha|isascii|is..) causes undefined behavior.
    </description>
    <tag>bug</tag>
  </rule>

  <!-- ########### New in cppcheck 1.53 ########### -->
  <rule>
    <key>doubleCloseDir</key>
    <configkey>doubleCloseDir</configkey>
    <name>Directory handle is closed twice</name>
    <description>
      Directory handle is closed twice.
    </description>
  </rule>
  <rule>
    <key>doubleFree</key>
    <configkey>doubleFree</configkey>
    <name>Memory is freed twice</name>
    <description>
<![CDATA[
<p>
Memory or resource handle is freed twice.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/415.html" target="_blank">CWE-415: Double Free</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>invalidPrintfArgType_s</key>
    <configkey>invalidPrintfArgType_s</configkey>
    <name>Invalid printf argument type (character pointer required)</name>
    <description>
      Invalid printf argument type (character pointer required).
    </description>
  </rule>
  <rule>
    <key>invalidPrintfArgType_n</key>
    <configkey>invalidPrintfArgType_n</configkey>
    <name>Invalid printf argument type (integer pointer required)</name>
    <description>
      Invalid printf argument type (integer pointer required).
    </description>
  </rule>
  <rule>
    <key>invalidPrintfArgType_p</key>
    <configkey>invalidPrintfArgType_p</configkey>
    <name>Invalid printf argument type (integer or pointer required)</name>
    <description>
      Invalid printf argument type (integer or pointer required).
    </description>
  </rule>
  <rule>
    <key>invalidPrintfArgType_int</key>
    <configkey>invalidPrintfArgType_int</configkey>
    <name>Invalid printf argument type (integer required)</name>
    <description>
      Invalid printf argument type (integer required).
    </description>
  </rule>
  <rule>
    <key>invalidPrintfArgType_sint</key>
    <configkey>invalidPrintfArgType_sint</configkey>
    <name>Invalid printf argument type (signed integer required)</name>
    <description>
      Invalid printf argument type (signed integer required).
    </description>
  </rule>
  <rule>
    <key>invalidPrintfArgType_float</key>
    <configkey>invalidPrintfArgType_float</configkey>
    <name>Invalid printf argument type (floating point number required)</name>
    <description>
      Invalid printf argument type (floating point number required).
    </description>
  </rule>
  <rule>
    <key>invalidScanfArgType</key>
    <configkey>invalidScanfArgType</configkey>
    <name>scanf argument no. 1: requires non-const pointers or arrays as arguments</name>
    <description>
      scanf argument no. 1: requires non-const pointers or arrays as
      arguments.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsasctime</key>
    <configkey>obsoleteFunctionsasctime</configkey>
    <name>Avoid usage of the function 'asctime'</name>
    <description>
      The function 'asctime' is obsolete. It is recommended to use
      the function 'strftime' instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsasctime_r</key>
    <configkey>obsoleteFunctionsasctime_r</configkey>
    <name>Avoid usage of the function 'asctime_r'</name>
    <description>
      The function 'asctime_r' is obsolete. It is recommended to use
      the function 'strftime' instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsrand_r</key>
    <configkey>obsoleteFunctionsrand_r</configkey>
    <name>Avoid usage of the function 'rand_r'</name>
    <description>
      The function 'rand_r' is obsolete. It is recommended to use the
      function 'rand' instead.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionstmpnam</key>
    <configkey>obsoleteFunctionstmpnam</configkey>
    <name>Avoid usage of the function 'tmpnam'</name>
    <description>
      The function 'tmpnam' is obsolete. It is recommended to use
      either 'tmpfile', 'mkstemp', or 'mkdtemp' instead for this function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionstmpnam_r</key>
    <configkey>obsoleteFunctionstmpnam_r</configkey>
    <name>Avoid usage of the function 'tmpnam_r'</name>
    <description>
      The function 'tmpnam_r' is obsolete. It is recommended to use
      either 'tmpfile', 'mkstemp', or 'mkdtemp' instead for this function.
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionsutime</key>
    <configkey>obsoleteFunctionsutime</configkey>
    <name>Avoid usage of the function 'utime'</name>
    <description>
      The function 'utime' is obsolete. It is recommended to use the
      function 'utimensat' instead.
    </description>
  </rule>
  <rule>
    <key>wrongPrintfScanfArgNum</key>
    <configkey>wrongPrintfScanfArgNum</configkey>
    <name>Wrong number of parameters given to printf()</name>
    <description>
<![CDATA[
<p>
Wrong number of parameters given to printf().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/685.html" target="_blank">CWE-685: Function Call With Incorrect Number of Arguments</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>

  <!-- ########### New in cppcheck 1.54 ########### -->
  <rule>
    <key>uninitMemberVar</key>
    <configkey>uninitMemberVar</configkey>
    <name>Member variable is not initialized in the constructor</name>
    <description>
<![CDATA[<p>
Member variable is not initialized in the constructor.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=482" target="_blank">EXP33-C. Do not read uninitialized memory</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a></p>
]]>
    </description>
    <tag>cert</tag>
    <tag>bug</tag>
    <tag>cwe</tag>
    </rule>
  <rule>
    <key>redundantCondition</key>
    <configkey>redundantCondition</configkey>
    <name>Redundant condition is always true</name>
    <description>
<![CDATA[
<p>
Redundant condition: If <code>x > 11</code> the condition <code>x > 10</code> is always true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>invalidPointerCast</key>
    <configkey>invalidPointerCast</configkey>
    <name>Invalid pointer casting</name>
    <description>
      This casting is not portable due to different binary data representations on different platforms.
    </description>
  </rule>
  <rule>
    <key>virtualDestructor</key>
    <configkey>virtualDestructor</configkey>
    <name>Base classes should have virtual destructors</name>
    <description>
<![CDATA[
<p>
Class Base which is inherited by class Derived does not have a virtual destructor.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/404.html" target="_blank">CWE-404: Improper Resource Shutdown or Release</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>leakNoVarFunctionCall</key>
    <configkey>leakNoVarFunctionCall</configkey>
    <name>Memory leak across function calls</name>
    <description>
<![CDATA[
<p>
Memory allocated inside the called function is not freed by the caller function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/772.html" target="_blank">CWE-772: Missing Release of Resource after Effective Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>stlcstrReturn</key>
    <configkey>stlcstrReturn</configkey>
    <name>Redundant c_str()-conversion in functions return</name>
    <description>
      Returning the result of c_str() in a function that returns std::string is slow and redundant.
    </description>
  </rule>
  <rule>
    <key>stlcstrParam</key>
    <configkey>stlcstrParam</configkey>
    <name>Redundant c_str()-conversion in parameter passing</name>
    <description>
      Passing the result of c_str() to a function that takes std::string as argument 0 is slow and redundant.
    </description>
  </rule>

  <!-- ########### New in cppcheck 1.54 ########### -->
  <rule>
    <key>StlMissingComparison</key>
    <configkey>StlMissingComparison</configkey>
    <name>Missing bounds check for extra iterator increment in loop</name>
    <description>
      Missing bounds check for extra iterator increment in loop. The iterator incrementing is suspicious - it is incremented at line 'line-number-1' and then at line 'line-number-2'
      The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end.
    </description>
  </rule>
  <rule>
    <key>strncatUsage</key>
    <configkey>strncatUsage</configkey>
    <name>Dangerous usage of strncat</name>
    <description>
      Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append.
      strncat appends at max its 3rd parameter's amount of characters. The safe way to use strncat is to calculate remaining space in the buffer and use it as 3rd parameter.
    </description>
  </rule>

  <!-- ########### New in cppcheck 1.55 ########### -->
  <rule>
    <key>CastIntegerToAddressAtReturn</key>
    <configkey>CastIntegerToAddressAtReturn</configkey>
    <name>Returning an integer in a function with pointer return type is not portable</name>
    <description>
      <![CDATA[
<p>
Returning an integer (int/long/etc) in a function with pointer return type is not portable across different
platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows
and Linux they are of different width. In worst case you end up casting 64-bit integer down to 32-bit pointer.
The safe way is to always return a pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>IOWithoutPositioning</key>
    <configkey>IOWithoutPositioning</configkey>
    <name>Read and write operations without a call to a positioning function</name>
    <description>
<![CDATA[
<p>
Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behavior.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>bitwiseOnBoolean</key>
    <configkey>bitwiseOnBoolean</configkey>
    <name>Boolean variable is used in bitwise operation</name>
    <description>
<![CDATA[
<p>
Boolean variable 'varname' is used in bitwise operation. Did you mean '&&' or '||'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>deallocret</key>
    <configkey>deallocret</configkey>
    <name>Returning/dereferencing variable after it is deallocated / released</name>
    <description>
      Returning/dereferencing variable after it is deallocated / released.
<![CDATA[
<p>
Assignment of function parameter has no effect outside the function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/672.html" target="_blank">CWE-672: Operation on a Resource after Expiration or Release</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>invalidScanfFormatWidth</key>
    <configkey>invalidScanfFormatWidth</configkey>
    <name>wrong width for scanf parameter</name>
    <description>
<![CDATA[
<p>
Width 'parameter' given in format string (no. 'symbol' ) doesn't match destination buffer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/687.html" target="_blank">CWE-687: Function Call With Incorrectly Specified Argument Value</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>leakconfiguration</key>
    <configkey>leakconfiguration</configkey>
    <name>Function configuration is needed to establish if there is a leak or not</name>
    <description>
      Function configuration is needed to establish if there is a leak or not.
    </description>
  </rule>
  <rule>
    <key>moduloAlwaysTrueFalse</key>
    <configkey>moduloAlwaysTrueFalse</configkey>
    <name>Comparison of modulo result is predetermined</name>
    <description>
<![CDATA[
<p>
Comparison of modulo result is predetermined.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>pointerSize</key>
    <configkey>pointerSize</configkey>
    <name>Using size of pointer variable instead of size of its data</name>
    <description>
      Using size of pointer variable instead of size of its data.
    </description>
  </rule>
  <rule>
    <key>possibleReadlinkBufferOverrun</key>
    <configkey>possibleReadlinkBufferOverrun</configkey>
    <name>Function might return the full size of variable</name>
    <description>
      Function might return the full size of variable.
    </description>
  </rule>
  <rule>
    <key>readWriteOnlyFile</key>
    <configkey>readWriteOnlyFile</configkey>
    <name>Read operation on a file that was opened only for writing</name>
    <description>
<![CDATA[
<p>
Read operation on a file that was opened only for writing.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>redundantBitwiseOperationInSwitch</key>
    <configkey>redundantBitwiseOperationInSwitch</configkey>
    <name>Redundant bitwise operation on variable in switch</name>
    <description>
      Redundant bitwise operation on variable in switch.
    </description>
  </rule>
  <rule>
    <key>suspiciousSemicolon</key>
    <configkey>suspiciousSemicolon</configkey>
    <name>Suspicious use of ; at the end of 'if/for/while' statement</name>
    <description>
      Suspicious use of ; at the end of 'if/for/while' statement.
    </description>
  </rule>
  <rule>
    <key>useClosedFile</key>
    <configkey>useClosedFile</configkey>
    <name>Used file that is not opened</name>
    <description>
<![CDATA[
<p>
Used file that is not opened.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/910.html" target="_blank">CWE-910: Use of Expired File Descriptor</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    </rule>
  <rule>
    <key>useInitializationList</key>
    <configkey>useInitializationList</configkey>
    <name>member variable shall be initialized using constructor</name>
    <description>
<![CDATA[
<p>
When an object of a class is created, the constructors of all member variables are called consecutively
in the order the variables are declared, even if you don't explicitly write them to the initialization list.
You could avoid assigning 'symbol' a value by passing the value to the constructor in the initialization list.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>writeReadOnlyFile</key>
    <configkey>writeReadOnlyFile</configkey>
    <name>Write operation on a file that was opened only for reading</name>
    <description>
<![CDATA[
<p>
Write operation on a file that was opened only for reading.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <!-- ########### New in cppcheck 1.56 ########### -->
  <rule>
    <key>clarifyStatement</key>
    <configkey>clarifyStatement</configkey>
    <name>Check statement and clarify behavior</name>
    <description>
      A statement like '*A++;' might not do what you intended. 'operator*' is executed before postfix 'operator++'. Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?
    </description>
  </rule>
  <rule>
    <key>comparisonOfBoolWithInvalidComparator</key>
    <configkey>comparisonOfBoolWithInvalidComparator</configkey>
    <name>Comparison of a boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      Comparison of a boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.
    </description>
  </rule>
  <rule>
    <key>functionStatic</key>
    <configkey>functionStatic</configkey>
    <name>The member function 'funcname' can be static</name>
    <description>
      The member function 'funcname' can be static.
    </description>
  </rule>
  <rule>
    <key>incompleteArrayFill</key>
    <configkey>incompleteArrayFill</configkey>
    <name>Array 'buffer' is filled incompletely</name>
    <description>
      Array 'buffer' is filled incompletely.
    </description>
  </rule>
  <rule>
    <key>invalidPrintfArgType_uint</key>
    <configkey>invalidPrintfArgType_uint</configkey>
    <name>Invalid printf argument type (unsigned integer required)</name>
    <description>
      Invalid printf argument type (unsigned integer required)
    </description>
  </rule>
  <rule>
    <key>literalWithCharPtrCompare</key>
    <configkey>literalWithCharPtrCompare</configkey>
    <name>String literal compared with a variable</name>
    <description>
      String literal compared with a variable.
    </description>
  </rule>
  <rule>
    <key>pointerLessThanZero</key>
    <configkey>pointerLessThanZero</configkey>
    <name>A pointer can not be negative so it is either pointless or an error to check if it is</name>
    <description>
      A pointer can not be negative so it is either pointless or an error to check if it is.
    </description>
  </rule>
  <rule>
    <key>pointerPositive</key>
    <configkey>pointerPositive</configkey>
    <name>A pointer can not be negative so it is either pointless or an error to check if it is not</name>
    <description>
      A pointer can not be negative so it is either pointless or an error to check if it is not.
    </description>
  </rule>
  <rule>
    <key>redundantCopyLocalConst</key>
    <configkey>redundantCopyLocalConst</configkey>
    <name>Use const reference for 'varname' to avoid unnecessary data copying</name>
    <description>
      Use const reference for 'varname' to avoid unnecessary data copying.
    </description>
  </rule>
  <rule>
    <key>shiftNegative</key>
    <configkey>shiftNegative</configkey>
    <name>Shifting by a negative value</name>
    <description>
<![CDATA[<p>
Shifting a negative value is undefined behaviour.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=4385" target="_blank">INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>unknownPattern</key>
    <configkey>unknownPattern</configkey>
    <name>Unknown pattern used</name>
    <description>
      Unknown pattern used.
    </description>
  </rule>
  <rule>
    <key>uselessCallsEmpty</key>
    <configkey>uselessCallsEmpty</configkey>
    <name>Useless call of function 'empty()'</name>
    <description>
      Useless call of function 'empty()'. Did you intend to call 'clear()' instead?
    </description>
  </rule>
  <rule>
    <key>uselessCallsRemove</key>
    <configkey>uselessCallsRemove</configkey>
    <name>Return value of std::remove() ignored</name>
    <description>
      Return value of std::remove() ignored.
    </description>
  </rule>
  <rule>
    <key>ConfigurationNotChecked</key>
    <configkey>ConfigurationNotChecked</configkey>
    <name>
      Skipping configuration 'X' since the value of 'X' is unknown
    </name>
    <description>
      Skipping configuration 'X' since the value of 'X' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly.
    </description>
  </rule>
  <rule>
    <key>toomanyconfigs</key>
    <configkey>toomanyconfigs</configkey>
    <name>
      Too many #ifdef configurations - cppcheck only checks 12 configurations
    </name>
    <description>
<![CDATA[
<p>
Too many #ifdef configurations - cppcheck only checks 12 configurations. Use --force to check all configurations. For more details, use --enable=information.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <!-- ########### New in cppcheck 1.57 ########### -->
  <rule>
    <key>CastAddressToIntegerAtReturn</key>
    <configkey>CastAddressToIntegerAtReturn</configkey>
    <name>Returning an address value in a function with integer return type is not portable</name>
    <description>
      <![CDATA[
<p>
Returning an address value in a function with integer (int/long/etc) return type is not portable across
different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in
64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit address down
to 32-bit integer. The safe way is to always return an integer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>comparisonOfBoolWithBoolError</key>
    <configkey>comparisonOfBoolWithBoolError</configkey>
    <name>Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
<![CDATA[
<p>
The variable 'expression' is of type 'bool' and comparing 'bool' value using relational (<, >, <= or >=) operator could cause unexpected results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>comparisonOfFuncReturningBoolError</key>
    <configkey>comparisonOfFuncReturningBoolError</configkey>
    <name>Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
<![CDATA[
<p>
The return type of function 'expression1' and function 'expression2' is 'bool' and result is of type 'bool'. 
Comparing 'bool' value using relational (<, >, <= or >=) operator could cause unexpected results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>comparisonOfTwoFuncsReturningBoolError</key>
    <configkey>comparisonOfTwoFuncsReturningBoolError</configkey>
    <name>Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
<![CDATA[
<p>
The return type of function 'expression1' and function 'expression2' is 'bool' and result is of type 'bool'.
Comparing 'bool' value using relational (<, >, <= or >=) operator could cause unexpected results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>copyCtorPointerCopying</key>
    <configkey>copyCtorPointerCopying</configkey>
    <name>Value of pointer 'varname', which points to allocated memory, is copied in copy constructor instead of allocating new memory</name>
    <description>
<![CDATA[
<p>
Value of pointer 'varname', which points to allocated memory, is copied in copy constructor instead of allocating new memory.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>invalidFree</key>
    <configkey>invalidFree</configkey>
    <name>Invalid memory address freed</name>
    <description>
      Invalid memory address freed.
    </description>
  </rule>
  <rule>
    <key>invalidLengthModifierError</key>
    <configkey>invalidLengthModifierError</configkey>
    <name>'modifier' in format string is a length modifier and cannot be used without a conversion specifier</name>
    <description>
      'modifier' in format string is a length modifier and cannot be used without a conversion specifier.
    </description>
  </rule>
  <rule>
    <key>noCopyConstructor</key>
    <configkey>noCopyConstructor</configkey>
    <name>'classname' does not have a copy constructor which is recommended since the class contains a pointer to allocated memory</name>
    <description>
<![CDATA[
<p>
'classname' does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>oppositeInnerCondition</key>
    <configkey>oppositeInnerCondition</configkey>
    <name>Opposite conditions in nested 'if' blocks lead to a dead code block</name>
    <description>
<![CDATA[
<p>
Opposite conditions in nested 'if' blocks lead to a dead code block.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>redundantAssignment</key>
    <configkey>redundantAssignment</configkey>
    <name>Variable 'var' is reassigned a value before the old one has been used</name>
    <description>
      Variable 'var' is reassigned a value before the old one has been used.
    </description>
  </rule>
  <rule>
    <key>redundantCopyInSwitch</key>
    <configkey>redundantCopyInSwitch</configkey>
    <name>Buffer 'var' is being written before its old content has been used</name>
    <description>
      Buffer 'var' is being written before its old content has been used. 'break;' missing?
    </description>
  </rule>
  <rule>
    <key>redundantNextPrevious</key>
    <configkey>redundantNextPrevious</configkey>
    <name>Call to 'Token::func1()' followed by 'Token::func2()' can be simplified</name>
    <description>
      Call to 'Token::func1()' followed by 'Token::func2()' can be simplified.
    </description>
  </rule>
  <rule>
    <key>unsafeClassCanLeak</key>
    <configkey>unsafeClassCanLeak</configkey>
    <name>Class 'classname' is unsafe, 'varname' can leak by wrong usage</name>
    <description>
      Class 'classname' is unsafe, 'varname' can leak by wrong usage.
    </description>
  </rule>
  <rule>
    <key>redundantCopy</key>
    <configkey>redundantCopy</configkey>
    <name>Buffer 'var' is being written before its old content has been used</name>
    <description>
      Buffer 'var' is being written before its old content has been used.
    </description>
  </rule>

  <!-- ########### New in cppcheck 1.58 ########### -->
  <rule>
    <key>argumentSize</key>
    <configkey>argumentSize</configkey>
    <name>
      Passing too small array as argument.
    </name>
    <description>
<![CDATA[
<p>
The array 'varname' is too small, the function 'functionName' expects a bigger one.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>

  <!-- ########### New in cppcheck 1.59 ########### -->
  <rule>
    <key>checkCastIntToCharAndBack</key>
    <configkey>checkCastIntToCharAndBack</configkey>
    <name>
      Storing func_name() return value in char variable and then comparing with EOF.
    </name>
    <description>
      Storing func_name() return value in char variable and then comparing with EOF.
    </description>
  </rule>

  <rule>
    <key>mallocOnClassError</key>
    <configkey>mallocOnClassError</configkey>
    <name>
       Memory for class instance allocated with malloc(), but class provides constructors.
    </name>
    <description>
<![CDATA[
<p>
Memory for class instance allocated with malloc(), but class provides constructors.
This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>mallocOnClassWarning</key>
    <configkey>mallocOnClassWarning</configkey>
    <name>
      Memory for class instance allocated with malloc(), but class provides constructors.
    </name>
    <description>
<![CDATA[
<p>
Memory for class instance allocated with malloc(), but class provides constructors.
This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <rule>
    <key>mismatchingBitAnd</key>
    <configkey>mismatchingBitAnd</configkey>
    <name>
      Mismatching bitmasks.
    </name>
    <description>
<![CDATA[
<p>
Mismatching bitmasks. Result is always 0
<code>
X = Y & 0xf0; 
Z = X & 0x1;
</code>
results => Z=0
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <rule>
    <key>missingIncludeSystem</key>
    <configkey>missingIncludeSystem</configkey>
    <name>
      Included files not found.
    </name>
    <description>
      Include files not found. Please note: Cppcheck does not need standard library headers to get proper results.
    </description>
    <tag>tool-error</tag>
  </rule>

  <rule>
    <key>stlBoundaries</key>
    <configkey>stlBoundaries</configkey>
    <name>
      Dangerous iterator comparison using operator &lt;.
    </name>
    <description>
<![CDATA[
<p>
Dangerous iterator comparison using 'operator<' on iterator.
This is dangerous since the order of items in the container is not guaranteed. 
One should use 'operator!=' instead to compare iterators.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <rule>
    <key>tooBigSleepTime</key>
    <configkey>tooBigSleepTime</configkey>
    <name>
      Invalid argument for usleep
    </name>
    <description>
      The argument of usleep must be less than 1000000.
    </description>
  </rule>

  <rule>
    <key>uninitStructMember</key>
    <configkey>uninitStructMember</configkey>
    <name>
      Uninitialized struct member
    </name>
    <description>
<![CDATA[<p>
Missing initialization for a struct member.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=482" target="_blank">EXP33-C. Do not read uninitialized memory</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/908.html" target="_blank">CWE-908: Use of Uninitialized Resource</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>

  <rule>
    <key>uselessAssignmentPtrArg</key>
    <configkey>uselessAssignmentPtrArg</configkey>
    <name>
      Effectless function parameter assignment.
    </name>
    <description>
<![CDATA[
<p>
Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>varFuncNullUB</key>
    <configkey>varFuncNullUB</configkey>
    <name>
      Passing NULL after the last typed argument to a variadic function leads to undefined behavior.
    </name>
    <description>
      Passing NULL after the last typed argument to a variadic function leads to undefined behavior.
    </description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>writeOutsideBufferSize</key>
    <configkey>writeOutsideBufferSize</configkey>
    <name>
      Writing '1' bytes outside buffer size.
    </name>
    <description>
      Writing '1' bytes outside buffer size.
    </description>
  </rule>

  <rule>
    <key>wrongPipeParameterSize</key>
    <configkey>wrongPipeParameterSize</configkey>
    <name>
      A buffer must have size of 2 integers if used as parameter of pipe().
    </name>
    <description>
<![CDATA[
<p>
A buffer must have size of 2 integers if used as parameter of pipe().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <rule>
    <key>class_X_Y</key>
    <configkey>class_X_Y</configkey>
    <name>Unhandled code</name>
    <description>
      This code is not handled. You can use -I or --include to add handling of this code.
    </description>
  </rule>

  <!-- ########### New in cppcheck 1.60 ########### -->
  <rule>
    <key>derefInvalidIterator</key>
    <configkey>derefInvalidIterator</configkey>
    <name>
      Possible dereference of an invalid iterator
    </name>
    <description>
      Possible dereference of an invalid iterator
    </description>
  </rule>

  <!-- ########### New in cppcheck 1.61 ########### -->
  <rule>
    <key>arithOperationsOnVoidPointer</key>
    <configkey>arithOperationsOnVoidPointer</configkey>
    <name>
      Undefined pointer calculation behavior
    </name>
    <description>
      When using void pointers in calculations, the behavior is undefined.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>commaSeparatedReturn</key>
    <configkey>commaSeparatedReturn</configkey>
    <name>
      Usage of comma in return statements
    </name>
    <description>
      Do not use the comma in return statements: it can be easily be misread as a ';'.
    </description>
  </rule>
  <rule>
    <key>nanInArithmeticExpression</key>
    <configkey>nanInArithmeticExpression</configkey>
    <name>
      Using NaN/Inf in a computation.
    </name>
    <description>
      Using NaN/Inf in a computation.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>sizeofDereferencedVoidPointer</key>
    <configkey>sizeofDereferencedVoidPointer</configkey>
    <name>
      Usage of 'sizeof' on dereferenced void pointer.
    </name>
    <description>
      The behavior of 'sizeof(void)' is not covered by the ISO C standard.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>sizeofVoid</key>
    <configkey>sizeofVoid</configkey>
    <name>
      Behavior of 'sizeof(void)' is undefined
    </name>
    <description>
      Behavior of 'sizeof(void)' is not covered by the ISO C standard.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>wrongPrintfScanfParameterPositionError</key>
    <configkey>wrongPrintfScanfParameterPositionError</configkey>
    <name>
      printf: referencing parameter 2 while 1 arguments given.
    </name>
    <description>
      printf: referencing parameter 2 while 1 arguments given.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>obsoleteFunctionsctime_r</key>
    <configkey>obsoleteFunctionsctime_r</configkey>
    <name>
      Obsolete function 'ctime_r' called
    </name>
    <description>
      Obsolete function 'ctime_r' called. It is recommended to use the function 'strftime' instead.
    </description>
  </rule>

  <!-- ########### New in cppcheck 1.62 ########### -->
  <rule>
    <key>duplInheritedMember</key>
    <configkey>duplInheritedMember</configkey>
    <name>
      Redefinition of a member variable in a subclass.
    </name>
    <description>
<![CDATA[
<p>
 A subclass defines a member variable which is already defined in its parent class.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>invalidScanfArgType_int</key>
    <configkey>invalidScanfArgType_int</configkey>
    <name>Mismatch in string format: 'unsigned int *' vs 'DWORD *'</name>
    <description>
      The format string requires 'unsigned int *' but the argument type is 'DWORD * {aka unsigned long *}'
    </description>
  </rule>
  <rule>
    <key>invalidScanfArgType_float</key>
    <configkey>invalidScanfArgType_float</configkey>
    <name>Mismatch in string format: 'float *' vs Unknown.</name>
    <description>
      %f in format string requires 'float *' but the argument type is Unknown.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>invalidScanfArgType_s</key>
    <configkey>invalidScanfArgType_s</configkey>
    <name>Mismatch in string format: 'char *' vs Unknown.</name>
    <description>
      %s in format string requires a 'char *' but the argument type is Unknown.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>comparisonFunctionIsAlwaysTrueOrFalse</key>
    <configkey>comparisonFunctionIsAlwaysTrueOrFalse</configkey>
    <name>Suspicious variable comparison with isless()</name>
    <description>
      Comparison of two identical variables with isless(varName,varName) evaluates always to false.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>zerodivcond</key>
    <configkey>zerodivcond</configkey>
    <name>Potential division by zero</name>
    <description>
<![CDATA[<p>
Either the condition is useless or there is division by zero.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=624" target="_blank">INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>

  <!-- ########### New in cppcheck 1.63 ########### -->
  <rule>
    <key>assertWithSideEffect</key>
    <configkey>assertWithSideEffect</configkey>
    <name>Assert with side effect</name>
    <description>
      <![CDATA[
<p>
Non-pure function: 'functionName' is called inside assert statement.
Assert statements are removed from release builds so the code inside
assert statement is not executed. If the code is needed also in release
builds, this is a bug.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>pointerArithBool</key>
    <configkey>pointerArithBool</configkey>
    <name>Pointer arithmetic conversion</name>
    <description>
<![CDATA[
<p>
Converting pointer arithmetic result to bool. The boolean result is always true unless there is pointer arithmetic overflow, 
and overflow is undefined behaviour. Probably a dereference is forgotten.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>leakReturnValNotUsed</key>
    <configkey>leakReturnValNotUsed</configkey>
    <name>Leak return value</name>
    <description>
<![CDATA[<p>
Return value of allocation function is not used.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=445" target="_blank">MEM31-C. Free dynamically allocated memory when no longer needed</a></p>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=17924853" target="_blank">EXP12-C. Do not ignore values returned by functions</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/771.html" target="_blank">CWE-771: Missing Reference to Active Allocated Resource</a></p>
]]>
    </description>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>invalidFunctionArg</key>
    <configkey>invalidFunctionArg</configkey>
    <name>Invalid function argument</name>
    <description>
<![CDATA[
<p>
A function gets passed an invalid argument.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>invalidFunctionArgBool</key>
    <configkey>invalidFunctionArgBool</configkey>
    <name>Invalid function bool argument</name>
    <description>
<![CDATA[
<p>
A function gets passed an invalid argument. A non-boolean value is required.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>

  <!-- ########### New in cppcheck 1.64 ########### -->
  <rule>
    <key>negativeMemoryAllocationSize</key>
    <configkey>negativeMemoryAllocationSize</configkey>
    <name>Memory allocation is negative</name>
    <description>
<![CDATA[
<p>
Memory allocation size have to be greater or equal to 0.
Negative allocation size has no specified behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/131.html" target="_blank">CWE-131: Incorrect Calculation of Buffer Size</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>memsetFloat</key>
    <configkey>memsetFloat</configkey>
    <name>Memset Float</name>
    <description>
      The 2nd memset() argument is a float, its representation is implementation defined.
    </description>
  </rule>
  <rule>
    <key>memsetValueOutOfRange</key>
    <configkey>memsetValueOutOfRange</configkey>
    <name>Memset value out of range</name>
    <description>
<![CDATA[<p>
The 2nd memset() argument doesn't fit into an 'unsigned char'.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=325" target="_blank">INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>
    <!-- ########### New in cppcheck 1.65 ########### -->
  <rule>
    <key>exceptThrowInNoexecptFunction</key>
    <configkey>exceptThrowInNoexecptFunction</configkey>
    <name>Exception thrown in noexcept function</name>
    <description>
      Inproper function declaration using noexcep.
      <!-- see also http://aristeia.com/EC++11-14/noexcept%202014-03-31.pdf (draft) -->
    </description>
  </rule>
  <rule>
    <key>exceptThrowInNoThrowFunction</key>
    <configkey>exceptThrowInNoThrowFunction</configkey>
    <name>Exception thrown in nothrow() function</name>
    <description>
      Function is decared as nothrow and but exceptions might occure.
    </description>
  </rule>
  <rule>
    <key>exceptThrowInAttributeNoThrowFunction</key>
    <configkey>exceptThrowInAttributeNoThrowFunction</configkey>
    <name>Exception thrown in __attribute__((nothrow)) function</name>
    <description>
      Exception thrown in __attribute__((nothrow)) function.
    </description>
  </rule>
  <rule>
    <key>exceptThrowInDeclspecNoThrowFunction</key>
    <configkey>exceptThrowInDeclspecNoThrowFunction</configkey>
    <name>Exception thrown in __declspec(nothrow) function</name>
    <description>
      Exception thrown in __declspec(nothrow) function.
    </description>
  </rule>
  <rule>
    <key>seekOnAppendedFile</key>
    <configkey>seekOnAppendedFile</configkey>
    <name>Repositioning operation in append mode</name>
    <description>
      Repositioning operation performed on a file opened in append mode has no effect.
    </description>
  </rule>
    <!-- ########### New in cppcheck 1.66 ########### -->
  <rule>
    <key>arrayIndexOutOfBoundsCond</key>
    <configkey>arrayIndexOutOfBoundsCond</configkey>
    <name>Array index out of bounds</name>
    <description>
<![CDATA[<p>
The array access using this index may be out of bounds.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=47677453" target="_blank">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/119.html" target="_blank">CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer</a></p>
]]>
</description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>charLiteralWithCharPtrCompare</key>
    <configkey>charLiteralWithCharPtrCompare</configkey>
    <name>Char literal compared with pointer</name>
    <description>
      Char literal compared with a pointer. Did you intend to dereference it?
    </description>
  </rule>
  <rule>
    <key>obsoleteFunctionasctime</key>
    <configkey>obsoleteFunctionasctime</configkey>
    <name>Avoid usage of the function 'asctime'</name>
    <description>
      The function 'asctime' is obsolete. It is recommended to use
      the function 'strftime' instead.
    </description>
  </rule>
    <!-- ########### New in cppcheck 1.67 ########### -->
  <rule>
    <key>deadpointer</key>
    <configkey>deadpointer</configkey>
    <name>Dead pointer usage</name>
    <description>
<![CDATA[
<p>
Pointer &apos;pointer&apos; is dead if it has been assigned &apos;&amp;x&apos; at line 0.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/825.html" target="_blank">CWE-825: Expired Pointer Dereference</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>ignoredReturnValue</key>
    <configkey>ignoredReturnValue</configkey>
    <name>Return value of  malloc() not used</name>
    <description>
<![CDATA[<p>
Return value of function malloc() is not used.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=17924853" target="_blank">EXP12-C. Do not ignore values returned by functions</a></p>
]]>
</description>
    <tag>cert</tag>
  </rule>
  <rule>
    <key>integerOverflow</key>
    <configkey>integerOverflow</configkey>
    <name>Signed integer overflow for expression</name>
    <description>
      Signed integer overflow for expression.
    </description>
  </rule>
  <rule>
    <key>invalidscanf_libc</key>
    <configkey>invalidscanf_libc</configkey>
    <name>scanf without field width limits can crash</name>
    <description>
      scanf without field width limits can crash with huge input data on some versions of libc.
    </description>
  </rule>
  <rule>
    <key>memsetClassFloat</key>
    <configkey>memsetClassFloat</configkey>
    <name>memset is used on class which contains a floating point number</name>
    <description>
<![CDATA[
<p>
Using memset() on class which contains a floating point number.
This is not portable because memset() sets each byte of a block of memory to a specific value and
the actual representation of a floating-point value is implementation defined.
<i>Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0.</i>
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/590.html" target="_blank">CWE-590: Free of Memory not on the Heap</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>memsetClassReference</key>
    <configkey>memsetClassReference</configkey>
    <name>Using memory function on class that contains references</name>
    <description>
<![CDATA[
<p>
Using "memfunc" on class that contains a reference.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/590.html" target="_blank">CWE-590: Free of Memory not on the Heap</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>selfInitialization</key>
    <configkey>selfInitialization</configkey>
    <name>Member variable is initialized by itself.</name>
    <description>
<![CDATA[
<p>
Member variable 'var' is initialized by itself.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>shiftTooManyBits</key>
    <configkey>shiftTooManyBits</configkey>
    <name>Shifting 32-bit value by 64 bits is undefined behaviour</name>
    <description>
<![CDATA[<p>
Shifting 32-bit value by 64 bits is undefined behaviour.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=4385" target="_blank">INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>signConversion</key>
    <configkey>signConversion</configkey>
    <name>Suspicious sign conversion of var in calculation</name>
    <description>
      Suspicious code: sign conversion of var in calculation, even though var can have a negative value.
    </description>
  </rule>
  <rule>
    <key>sizeofDivisionMemfunc</key>
    <configkey>sizeofDivisionMemfunc</configkey>
    <name>Suspicious calculation of memset() bytes size</name>
    <description>
      Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead?
    </description>
  </rule>
  <rule>
    <key>unpreciseMathCall</key>
    <configkey>unpreciseMathCall</configkey>
    <name>Avoid loss of precision for expression</name>
    <description>
      Expression &apos;1 - erf(x)&apos; can be replaced by &apos;erfc(x)&apos; to avoid loss of precision.
    </description>
  </rule>
  <rule>
    <key>uselessAssignmentArg</key>
    <configkey>uselessAssignmentArg</configkey>
    <name>Assignment of function parameter has no effect outside the function</name>
    <description>
<![CDATA[
<p>
Assignment of function parameter has no effect outside the function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
     ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>va_end_missing</key>
    <configkey>va_end_missing</configkey>
    <name>va_list not closed by va_end()</name>
    <description>
<![CDATA[
<p>
va_list 'vl' was opened but not closed by va_end().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>va_list_usedBeforeStarted</key>
    <configkey>va_list_usedBeforeStarted</configkey>
    <name>va_list used before va_start() call</name>
    <description>
<![CDATA[
<p>
va_list 'vl' used before va_start() was called.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>va_start_referencePassed</key>
    <configkey>va_start_referencePassed</configkey>
    <name>Using reference as parameter for va_start() is undefined behaviour</name>
    <description>
<![CDATA[
<p>
Using reference &apos;arg1&apos; as parameter for va_start() results in undefined behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>va_start_subsequentCalls</key>
    <configkey>va_start_subsequentCalls</configkey>
    <name>va_start() or va_copy() called without va_end() inbetween</name>
    <description>
<![CDATA[
<p>
va_start() or va_copy() called subsequently on 'vl' without va_end() inbetween.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    </rule>
  <rule>
    <key>va_start_wrongParameter</key>
    <configkey>va_start_wrongParameter</configkey>
    <name>Given argument to va_start() is not last one</name>
    <description>
      &apos;arg1&apos; given to va_start() is not last named argument of the function. Did you intend to pass &apos;arg2&apos;?.
    </description>
  </rule>
  <rule>
    <key>unmatchedSuppression</key>
    <configkey>unmatchedSuppression</configkey>
    <name>Unmatched suppression: unusedFunction</name>
    <description>
      Unmatched suppression: unusedFunction.
    </description>
  </rule>
    <!-- ########### New in cppcheck 1.69 Dev ########### -->
  <rule>
    <key>duplicateExpressionTernary</key>
    <configkey>duplicateExpressionTernary</configkey>
    <name>Same expression in both branches of ternary operator</name>
    <description>
      Same expression in both branches of ternary operator.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>noExplicitConstructor</key>
    <configkey>noExplicitConstructor</configkey>
    <name>Class has a constructor with 1 argument that is not explicit</name>
    <description>
      Class &apos;classname&apos; has a constructor with 1 argument that is not explicit.
    </description>
  </rule>
  <rule>
    <key>noExplicitCopyMoveConstructor</key>
    <configkey>noExplicitCopyMoveConstructor</configkey>
    <name>Abstract class has a copy/move constructor that is not explicit</name>
    <description>
      Abstract class &apos;classname&apos; has a copy/move constructor that is not explicit.
    </description>
  </rule>
  <rule>
    <key>operatorEqMissingReturnStatement</key>
    <configkey>operatorEqMissingReturnStatement</configkey>
    <name>Missing &apos;return&apos; statement in non-void function causes undefined behavior</name>
    <description>
<![CDATA[
<p>
No <code>return</code> statement in non-void function causes undefined behavior.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>operatorEqShouldBeLeftUnimplemented</key>
    <configkey>operatorEqShouldBeLeftUnimplemented</configkey>
    <name>&apos;operator=&apos; should either return reference to &apos;this&apos;</name>
    <description>
<![CDATA[
<p>
'operator=' should either return reference to 'this'instance or be declared private and left unimplemented.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a>
</p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>redundantPointerOp</key>
    <configkey>redundantPointerOp</configkey>
    <name>Redundant pointer operation on varname</name>
    <description>
      Redundant pointer operation on varname - it&apos;s already a pointer.
    </description>
  </rule>
  <rule>
    <key>throwInNoexceptFunction</key>
    <configkey>throwInNoexceptFunction</configkey>
    <name>Exception thrown in function declared not to throw exceptions</name>
    <description>
      Exception thrown in function declared not to throw exceptions.
    </description>
  </rule>
  <rule>
    <key>useAutoPointerMalloc</key>
    <configkey>useAutoPointerMalloc</configkey>
    <name>Object pointed by an &apos;auto_ptr&apos; is destroyed using operator &apos;delete&apos;</name>
    <description>
      Object pointed by an &apos;auto_ptr&apos; is destroyed using operator &apos;delete&apos;. You should not use &apos;auto_ptr&apos; for pointers obtained with function &apos;malloc&apos;.
    </description>
  </rule>
  <!-- ########### New in cppcheck 1.70 release ########### -->
  <rule>
    <key>negativeArraySize</key>
    <configkey>negativeArraySize</configkey>
    <name>Declaration of array &apos;identifier&apos; with negative size is undefined behaviour</name>
    <description>
<![CDATA[<p>
Declaration of array &apos;identifier&apos; with negative size is undefined behaviour.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=2681" target="_blank">ARR32-C. Ensure size arguments for variable length arrays are in a valid range</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>
  <rule>
    <key>badBitmaskCheck</key>
    <configkey>badBitmaskCheck</configkey>
    <name>Result of operator &apos;|&apos; is always true if one operand is non-zero</name>
    <description>
      Result of operator &apos;|&apos; is always true if one operand is non-zero. Did you intend to use &apos;&amp;&apos;?
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>knownConditionTrueFalse</key>
    <configkey>knownConditionTrueFalse</configkey>
    <name>Condition &apos;x&apos; is always true</name>
    <description>
      Condition &apos;x&apos; is always true.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>nullPointerDefaultArg</key>
    <configkey>nullPointerDefaultArg</configkey>
    <name>Possible null pointer dereference if the default parameter value is used: pointer</name>
    <description>
<![CDATA[<p>
Possible null pointer dereference if the default parameter value is used: pointer.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers" target="_blank">EXP34-C. Do not dereference null pointers</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>
  <rule>
    <key>nullPointerRedundantCheck</key>
    <configkey>nullPointerRedundantCheck</configkey>
    <name>Either the condition is redundant or there is possible null pointer dereference: pointer</name>
    <description>
<![CDATA[<p>
Either the condition is redundant or there is possible null pointer dereference: pointer.
</p><h2>References</h2>
<p><a href="https://www.securecoding.cert.org/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers" target="_blank">EXP34-C. Do not dereference null pointers</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>
  <rule>
    <key>obsoleteFunctionsalloca</key>
    <configkey>obsoleteFunctionsalloca</configkey>
    <name>Obsolete function &apos;alloca&apos; called</name>
    <description>
      Obsolete function &apos;alloca&apos; called. In C99 and later it is recommended to use a variable length array instead.
    </description>
  </rule>
  <rule>
    <key>raceAfterInterlockedDecrement</key>
    <configkey>raceAfterInterlockedDecrement</configkey>
    <name>Race condition: non-interlocked access after InterlockedDecrement()</name>
    <description>
      Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead.
    </description>
  </rule>
  <rule>
    <key>unusedLabel</key>
    <configkey>unusedLabel</configkey>
    <name>Label &apos;identifier&apos; is not used</name>
    <description>
      Label &apos;identifier&apos; is not used.
    </description>
  </rule>
  <rule>
    <key>stringLiteralWrite</key>
    <configkey>stringLiteralWrite</configkey>
    <name>Modifying string literal directly or indirectly is undefined behaviour</name>
    <description>
      Modifying string literal directly or indirectly is undefined behaviour.
    </description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>truncLongCastAssignment</key>
    <configkey>truncLongCastAssignment</configkey>
    <name>int result is assigned to long variable (potential truncation)</name>
    <description>
      int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information.
    </description>
  </rule>
  <rule>
    <key>truncLongCastReturn</key>
    <configkey>truncLongCastReturn</configkey>
    <name>int result is returned as long value (potential truncation)</name>
    <description>
      int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information.
    </description>
  </rule>
  <!-- ########### New in cppcheck 1.72 ########### -->
  <rule>
    <key>assignBoolToFloat</key>
    <configkey>assignBoolToFloat</configkey>
    <name>Boolean value assigned to floating point variable</name>
    <description>
      Boolean value assigned to floating point variable.
    </description>
  </rule>
  <rule>
    <key>invalidTestForOverflow</key>
    <configkey>invalidTestForOverflow</configkey>
    <name>Invalid test for overflow (undefined behavior)</name>
    <description>
      Invalid test for overflow &apos;x + u &lt; x&apos;. Condition is always false unless there is overflow, and overflow is UB.
    </description>
  </rule>
  <rule>
    <key>unknownEvaluationOrder</key>
    <configkey>unknownEvaluationOrder</configkey>
    <name>Expression depends on order of evaluation (side effects)</name>
    <description>
      Expression &apos;x = x++;&apos; depends on order of evaluation of side effects.
    </description>
  </rule>
  <!-- ########### New in cppcheck 1.73 ########### -->
  <rule>
    <key>signedCharArrayIndex</key>
    <configkey>signedCharArrayIndex</configkey>
    <name>Signed 'char' type used as array index</name>
    <description>
      Signed 'char' type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension.
    </description>
  </rule>
  <rule>
    <key>unknownSignCharArrayIndex</key>
    <configkey>unknownSignCharArrayIndex</configkey>
    <name>'char' type used as array index</name>
    <description>
      'char' type used as array index. Values greater that 127 will be treated depending on whether 'char' is signed or unsigned on target platform.
    </description>
  </rule>
  <rule>
    <key>unusedLabelSwitch</key>
    <configkey>unusedLabelSwitch</configkey>
    <name>Label is not used. </name>
    <description>
      Label is not used.
    </description>
  </rule>
 </rules>

<!-- ########### Deprecated as of 1.63 ########### -->
<!-- tooBigSleepTime -->
<!-- dangerousUsageStrtol -->
<!-- wrongcctypecall -->

<!-- ########### Deprecated as of 1.63.1 ########### -->
<!-- dangerousUsageStrtol -->
<!-- conditionAlwaysTrueFalse -->
<!-- sizeArgumentAsChar -->
<!-- complexPatternError -->
<!-- missingPercentCharacter -->
<!-- redundantStrcpyInSwitch -->
<!-- stlcstrthrow -->
<!-- wrongcctypecall -->
<!-- debug -->
<!-- strncatUsage -->
<!-- invalidScanfFormatWidth -->
<!-- leakconfiguration -->
<!-- missingScanfFormatWidth -->
<!-- redundantOperationInSwitch -->
<!-- unknownPattern -->
<!-- invalidFree -->
<!-- invalidLengthModifierError -->
<!-- tooBigSleepTime -->
<!-- class_X_Y -->

<!-- ########### Deprecated as of 1.64 ########### -->
<!-- duplicateBranch -->
